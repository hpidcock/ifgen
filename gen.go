package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"go/types"
	"os"
	"os/exec"
	"path/filepath"

	"golang.org/x/tools/go/ast/astutil"
)

type gen struct {
	fs       *token.FileSet
	file     *ast.File
	fileName string
	imports  map[string]int
}

func NewGen(packageName string, fileName string, buildFlag string) *gen {
	fs := token.NewFileSet()
	initial := fmt.Sprintf(template, packageName, buildFlag)
	file, err := parser.ParseFile(fs, fileName, initial, parser.AllErrors|parser.ParseComments)
	if err != nil {
		panic(err)
	}
	return &gen{
		fs:       fs,
		file:     file,
		fileName: fileName,
		imports:  map[string]int{},
	}
}

func (g *gen) AddInterface(typ *types.Named, targetName string, srcPkgPath string, filterIn map[string]bool) error {
	out := &ast.InterfaceType{
		Methods: &ast.FieldList{},
	}
	for i := 0; i < typ.NumMethods(); i++ {
		meth := typ.Method(i)
		if !meth.Exported() {
			continue
		}
		if filterIn != nil && !filterIn[meth.Name()] {
			continue
		}

		sig := meth.Signature()

		funcType := &ast.FuncType{
			Params:  &ast.FieldList{},
			Results: &ast.FieldList{},
		}

		for j := 0; j < sig.Params().Len(); j++ {
			param := sig.Params().At(j)
			f := &ast.Field{}
			if param.Name() != "" {
				f.Names = append(f.Names, ast.NewIdent(param.Name()))
			}
			f.Type = astExprForType(param.Type(), srcPkgPath, g.imports)
			if sig.Variadic() && j == sig.Params().Len()-1 {
				f.Type = &ast.Ellipsis{
					Elt: f.Type.(*ast.ArrayType).Elt,
				}
			}
			funcType.Params.List = append(funcType.Params.List, f)
		}

		for j := 0; j < sig.Results().Len(); j++ {
			param := sig.Results().At(j)
			f := &ast.Field{}
			if param.Name() != "" {
				f.Names = append(f.Names, ast.NewIdent(param.Name()))
			}
			f.Type = astExprForType(param.Type(), srcPkgPath, g.imports)
			funcType.Results.List = append(funcType.Results.List, f)
		}
		field := &ast.Field{
			Names: []*ast.Ident{{
				Name: meth.Name(),
			}},
			Type: funcType,
			// TODO: add comment from source
		}
		out.Methods.List = append(out.Methods.List, field)
	}

	decl := &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{&ast.TypeSpec{
			Name: &ast.Ident{Name: targetName},
			Type: out,
		}},
	}
	g.file.Decls = append(g.file.Decls, decl)

	return nil
}

func (g *gen) Write(dir string) error {
	for path, index := range g.imports {
		astutil.AddNamedImport(g.fs, g.file, fmt.Sprintf("x%d", index), path)
	}

	buf := &bytes.Buffer{}
	err := printer.Fprint(buf, g.fs, g.file)
	if err != nil {
		return err
	}

	gofmt, _ := exec.LookPath("gofmt")
	if gofmt != "" {
		outBuf := &bytes.Buffer{}
		cmd := exec.Command(gofmt, "-s")
		cmd.Stdin = buf
		cmd.Stderr = os.Stderr
		cmd.Stdout = outBuf
		err := cmd.Run()
		if err != nil {
			return err
		}
		buf = outBuf
	}

	err = os.WriteFile(filepath.Join(dir, g.fileName), buf.Bytes(), 0600)
	if err != nil {
		return err
	}

	return nil
}

const template string = `// Code generated by ifgen. DO NOT EDIT.

package %s

//go:build %s

`
